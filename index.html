<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Batch crop save jpg</title>
<style>
  body {
    font-family: sans-serif;
  }
  #drop-zone {
    width: 100%;
    border: 2px dashed #ccc;
    padding: 20px;
    text-align: center;
    margin-bottom: 20px;
  }
  .image-container {
    display: inline-block;
    margin: 10px;
    vertical-align: top;
    border: 1px solid #ccc;
    padding: 10px;
  }
  canvas {
    border: 1px solid #333;
    display: block;
    margin-bottom: 10px;
  }
  #global-controls {
    margin: 20px 0;
  }
  #global-controls label {
    display: inline-block;
    width: 80px;
  }
  .per-image-controls {
    margin-top: 10px;
  }
  .per-image-controls label {
    display: inline-block;
    width: 50px;
  }
</style>
</head>
<body>

<div id="drop-zone">Drag & Drop Images Here</div>

<div id="global-controls">
  <h3>Global Crop Settings (used unless overridden by individual image):</h3>
  <label>X Pos:</label>
  <input id="globalXSlider" type="range" min="0" max="300" value="225" style="width:200px;vertical-align:middle;">
  <span id="globalXVal"></span><br>
  <label>Width:</label>
  <input id="globalWSlider" type="range" min="10" max="300" value="75" style="width:200px;vertical-align:middle;">
  <span id="globalWVal"></span><br><br>
  <label>Filename prefix:</label>
  <input id="filenamePrefix" type="text" value="filename" style="vertical-align:middle;">
</div>

<div id="image-list"></div>
<div>
  <button id="saveAllBtn">Save All Cropped as ZIP</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>
<script>
  const dropZone = document.getElementById('drop-zone');
  const imageList = document.getElementById('image-list');
  const saveAllBtn = document.getElementById('saveAllBtn');
  
  const globalXSlider = document.getElementById('globalXSlider');
  const globalWSlider = document.getElementById('globalWSlider');
  const globalXVal = document.getElementById('globalXVal');
  const globalWVal = document.getElementById('globalWVal');
  
  const filenamePrefixInput = document.getElementById('filenamePrefix');

  let imagesData = []; // Each: {originalImg, canvas, ctx, scaleFactor, overrideX, overrideW, localX, localW}

  let cropX = parseInt(globalXSlider.value, 10);
  let cropWidth = parseInt(globalWSlider.value, 10);

  globalXVal.textContent = cropX;
  globalWVal.textContent = cropWidth;

  // Prevent default drag behaviors
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, (e) => e.preventDefault(), false);
    document.body.addEventListener(eventName, (e) => e.preventDefault(), false);
  });

  // Highlight drop area when item is dragged over it
  ['dragenter', 'dragover'].forEach(eventName => {
    dropZone.addEventListener(eventName, () => {
      dropZone.style.backgroundColor = '#e6f7ff';
    }, false);
  });
  ['dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, () => {
      dropZone.style.backgroundColor = '';
    }, false);
  });

  // Handle dropped files
  dropZone.addEventListener('drop', (e) => {
    let dt = e.dataTransfer;
    let files = dt.files;
    handleFiles(files);
  }, false);

  function handleFiles(files) {
    [...files].forEach(previewFile);
  }

  function previewFile(file) {
    if (!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        const container = document.createElement('div');
        container.className = 'image-container';

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const displayWidth = 300;
        const scaleFactor = displayWidth / img.width;
        const displayHeight = img.height * scaleFactor;
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

        container.appendChild(canvas);

        // Per-image controls
        const perImageControls = document.createElement('div');
        perImageControls.className = 'per-image-controls';
        
        // X Pos slider
        const xLabel = document.createElement('label');
        xLabel.textContent = 'X:';
        const xSlider = document.createElement('input');
        xSlider.type = 'range';
        xSlider.min = 0;
        xSlider.max = displayWidth;
        xSlider.value = cropX; // start with global default
        const xVal = document.createElement('span');
        xVal.textContent = xSlider.value;

        // Width slider
        const wLabel = document.createElement('label');
        wLabel.textContent = 'W:';
        const wSlider = document.createElement('input');
        wSlider.type = 'range';
        wSlider.min = 10;
        wSlider.max = displayWidth;
        wSlider.value = cropWidth; // start with global default
        const wVal = document.createElement('span');
        wVal.textContent = wSlider.value;

        perImageControls.appendChild(xLabel);
        perImageControls.appendChild(xSlider);
        perImageControls.appendChild(xVal);
        perImageControls.appendChild(document.createElement('br'));
        perImageControls.appendChild(wLabel);
        perImageControls.appendChild(wSlider);
        perImageControls.appendChild(wVal);

        container.appendChild(perImageControls);
        imageList.appendChild(container);

        const imageData = {
          originalImg: img,
          canvas: canvas,
          ctx: ctx,
          scaleFactor: scaleFactor,
          overrideX: false,
          overrideW: false,
          localX: parseInt(xSlider.value, 10),
          localW: parseInt(wSlider.value, 10)
        };
        imagesData.push(imageData);

        // Draw with current settings (currently global, since no overrides)
        drawCropOverlay(imageData);

        // Add event listeners for the per-image sliders
        xSlider.addEventListener('input', () => {
          imageData.localX = parseInt(xSlider.value, 10);
          xVal.textContent = xSlider.value;
          // User adjusted local X, so overrideX = true
          imageData.overrideX = true;
          drawCropOverlay(imageData);
        });

        wSlider.addEventListener('input', () => {
          imageData.localW = parseInt(wSlider.value, 10);
          wVal.textContent = wSlider.value;
          // User adjusted local W, so overrideW = true
          imageData.overrideW = true;
          drawCropOverlay(imageData);
        });
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  function drawCropOverlay(data) {
    const {ctx, canvas, originalImg, scaleFactor, overrideX, overrideW, localX, localW} = data;
    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    let finalX = overrideX ? localX : cropX;
    let finalW = overrideW ? localW : cropWidth;

    ctx.clearRect(0, 0, displayWidth, displayHeight);
    ctx.drawImage(originalImg, 0, 0, displayWidth, displayHeight);

    // Bound checking
    if (finalX + finalW > displayWidth) finalX = displayWidth - finalW;
    if (finalX < 0) finalX = 0;

    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.strokeRect(finalX, 0, finalW, displayHeight);

    // If we adjusted due to boundary and local overrides are active, update localX/W
    if (overrideX) data.localX = finalX;
    if (overrideW) data.localW = finalW;
  }

  globalXSlider.addEventListener('input', () => {
    cropX = parseInt(globalXSlider.value, 10);
    globalXVal.textContent = cropX;
    redrawAllImages();
  });

  globalWSlider.addEventListener('input', () => {
    cropWidth = parseInt(globalWSlider.value, 10);
    globalWVal.textContent = cropWidth;
    redrawAllImages();
  });

  function redrawAllImages() {
    // For images that do not override a dimension, update their local slider to match global value
    for (const data of imagesData) {
      const {canvas, overrideX, overrideW} = data;
      if (!overrideX) {
        // Update localX to match global and also update slider UI
        data.localX = cropX;
        const xSlider = canvas.parentNode.querySelector('.per-image-controls input[type=range]:first-of-type');
        const xVal = xSlider.nextSibling; 
        xSlider.value = cropX;
        xVal.textContent = cropX;
      }
      if (!overrideW) {
        // Update localW to match global and also update slider UI
        data.localW = cropWidth;
        const wSlider = canvas.parentNode.querySelectorAll('.per-image-controls input[type=range]')[1];
        const wVal = wSlider.nextSibling; 
        wSlider.value = cropWidth;
        wVal.textContent = cropWidth;
      }
    }

    for (const data of imagesData) {
      drawCropOverlay(data);
    }
  }

  saveAllBtn.addEventListener('click', async () => {
    const zip = new JSZip();
    const filenamePrefix = filenamePrefixInput.value.trim() || 'file';

    for (let i = 0; i < imagesData.length; i++) {
      const data = imagesData[i];
      const {originalImg, canvas, scaleFactor, overrideX, overrideW, localX, localW} = data;

      const displayWidth = canvas.width;
      const displayHeight = canvas.height;

      let finalX = overrideX ? localX : cropX;
      let finalW = overrideW ? localW : cropWidth;

      // Bound checking
      if (finalX + finalW > displayWidth) finalX = displayWidth - finalW;
      if (finalX < 0) finalX = 0;

      const origX = Math.round(finalX / scaleFactor);
      const origW = Math.round(finalW / scaleFactor);
      const origY = 0;
      const origH = originalImg.height; // full height

      // Create an off-screen canvas to crop
      const offCanvas = document.createElement('canvas');
      offCanvas.width = origW;
      offCanvas.height = origH;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(originalImg, origX, origY, origW, origH, 0, 0, origW, origH);

      // Convert to blob as JPEG
      const blob = await new Promise(resolve => offCanvas.toBlob(resolve, 'image/jpeg', 0.9));
      zip.file(`${filenamePrefix}${i+1}.jpg`, blob);
    }

    // Generate the zip file
    const content = await zip.generateAsync({type:"blob"});
    saveAs(content, `${filenamePrefix}.zip`);
  });
</script>
</body>
</html>
